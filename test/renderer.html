<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-dropdown-menu tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">
  <link rel="import" href="../../vaadin-list-box/vaadin-list-box.html">
  <link rel="import" href="../../vaadin-item/vaadin-item.html">
  <link rel="import" href="mock-item.html">
  <link rel="import" href="../vaadin-dropdown-menu.html">
  <link rel="import" href="not-animated-styles.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-dropdown-menu></vaadin-dropdown-menu>
    </template>
  </test-fixture>

  <test-fixture id="with-template">
    <template>
      <vaadin-dropdown-menu>
        <template>
          <vaadin-list-box>
            <mock-item>templatizer item</mock-item>
          </vaadin-list-box>
        </template>
      </vaadin-dropdown-menu>
    </template>
  </test-fixture>

  <test-fixture id="from-props">
    <template>
      <x-renderer></x-renderer>
    </template>
  </test-fixture>

  <dom-module id="x-renderer">
    <template>
      <vaadin-dropdown-menu renderer="[[renderer]]"></vaadin-dropdown-menu>
    </template>
    <script>
      customElements.whenDefined('vaadin-dropdown-menu').then(() => {
        class XRenderer extends Polymer.Element {
          static get is() {
            return 'x-renderer';
          }
          static get properties() {
            return {
              renderer: {
                type: Function,
                value: function() {
                  return function(root) {
                    if (!root.firstChild) {
                      const listBox = document.createElement('vaadin-list-box');
                      const item = document.createElement('mock-item');
                      item.textContent = 'renderer item';
                      listBox.appendChild(item);
                      root.appendChild(listBox);
                    }
                  };
                }
              }
            };
          }
        }
        customElements.define(XRenderer.is, XRenderer);
      });
    </script>
  </dom-module>

  <script>
    describe('vaadin-dropdown-menu renderer', () => {
      let rendererContent;

      beforeEach(function() {
        rendererContent = document.createElement('vaadin-list-box');
        const rendererItem = document.createElement('mock-item');
        rendererItem.textContent = 'renderer item';
        rendererContent.appendChild(rendererItem);
      });

      describe('without template', () => {
        let dropdown;

        beforeEach(() => dropdown = fixture('default'));

        it('should use renderer when it is defined', () => {
          dropdown.renderer = root => root.appendChild(rendererContent);
          expect(dropdown.shadowRoot.querySelector('vaadin-list-box mock-item').textContent.trim()).to.equal('renderer item');
        });

        it('should pass vaadin-dropdown-menu as owner to vaadin-overlay', () => {
          dropdown.renderer = (root, dropdownMenu, model) => {
            expect(dropdownMenu).to.eql(dropdown);
          };
        });

        it('should remove template when added after renderer', () => {
          dropdown.renderer = () => {};
          const template = document.createElement('template');
          expect(() => dropdown._contentTemplate = template).to.throw(Error);
          expect(dropdown._contentTemplate).to.be.not.ok;
        });
      });

      describe('with template', () => {
        let dropdown;

        beforeEach(() => dropdown = fixture('with-template'));

        it('should fallback to render content with Templatizer when renderer is not defined', () => {
          expect(dropdown.shadowRoot.querySelector('vaadin-list-box mock-item').textContent.trim()).to.equal('templatizer item');
        });

        it('should throw an error when setting a renderer if there is already a template', () => {
          expect(() => dropdown.renderer = () => {}).to.throw(Error);
        });

        it('should remove renderer when added after template', () => {
          expect(() => dropdown.renderer = () => {}).to.throw(Error);
          expect(dropdown.renderer).to.be.not.ok;
        });
      });

      describe('assigned through property binding', () => {
        let wrapper, dropdown;

        beforeEach(done => {
          customElements.whenDefined('x-renderer').then(() => {
            wrapper = fixture('from-props');
            dropdown = wrapper.shadowRoot.querySelector('vaadin-dropdown-menu');
            done();
          });
        });

        it('should render correctly when rendered assigned before shadow DOM is ready', () => {
          dropdown.opened = true;
          expect(dropdown._overlayElement.content.querySelector('mock-item').textContent.trim()).to.equal('renderer item');
        });
      });
    });
  </script>
</body>
